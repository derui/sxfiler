(************************************************)
(*       AUTOGENERATED FILE - DO NOT EDIT!      *)
(************************************************)
(* Generated by: ocaml-protoc-plugin            *)
(* https://github.com/issuu/ocaml-protoc-plugin *)
(************************************************)
(* Source: task.proto Syntax: proto3 Parameters: debug=false annot='[@@deriving eq, show, protocol
   ~driver:(module Protocol_conv_json.Json)]' opens=[] int64_as_int=true int32_as_int=true
   fixed_as_int=false singleton_record=true *)

open Ocaml_protoc_plugin.Runtime [@@warning "-33"]

module rec ReplyType : sig
  type t =
    | Overwrite
    | Rename
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_int : t -> int
  val from_int : int -> (t, [> Runtime'.Result.error ]) result
end = struct
  type t =
    | Overwrite
    | Rename
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_int = function Overwrite -> 0 | Rename -> 1
  let from_int = function 0 -> Ok Overwrite | 1 -> Ok Rename | n -> Error (`Unknown_enum_value n)
end

and TaskSuggestion : sig
  val name' : unit -> string

  type t = {
    suggestions : ReplyType.t list;
    itemName : string;
    taskId : string;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Runtime'.Writer.t
  val from_proto : Runtime'.Reader.t -> (t, [> Runtime'.Result.error ]) result
end = struct
  let name' () = "task.TaskSuggestion"

  type t = {
    suggestions : ReplyType.t list;
    itemName : string;
    taskId : string;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f:f' { suggestions; itemName; taskId } = f' [] suggestions itemName taskId in
    let spec =
      Runtime'.Serialize.C.(
        repeated (1, enum ReplyType.to_int, packed)
        ^:: basic (2, string, proto3)
        ^:: basic (3, string, proto3)
        ^:: nil)
    in
    let serialize = Runtime'.Serialize.serialize [] spec in
    fun t -> apply ~f:serialize t

  let from_proto =
    let constructor _extensions suggestions itemName taskId = { suggestions; itemName; taskId } in
    let spec =
      Runtime'.Deserialize.C.(
        repeated (1, enum ReplyType.from_int, packed)
        ^:: basic (2, string, proto3)
        ^:: basic (3, string, proto3)
        ^:: nil)
    in
    let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
    fun writer -> deserialize writer |> Runtime'.Result.open_error
end

and TaskReplyToOverwriteRequest : sig
  val name' : unit -> string

  type t = {
    taskId : string;
    overwrite : bool;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Runtime'.Writer.t
  val from_proto : Runtime'.Reader.t -> (t, [> Runtime'.Result.error ]) result
end = struct
  let name' () = "task.TaskReplyToOverwriteRequest"

  type t = {
    taskId : string;
    overwrite : bool;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f:f' { taskId; overwrite } = f' [] taskId overwrite in
    let spec =
      Runtime'.Serialize.C.(basic (1, string, proto3) ^:: basic (2, bool, proto3) ^:: nil)
    in
    let serialize = Runtime'.Serialize.serialize [] spec in
    fun t -> apply ~f:serialize t

  let from_proto =
    let constructor _extensions taskId overwrite = { taskId; overwrite } in
    let spec =
      Runtime'.Deserialize.C.(basic (1, string, proto3) ^:: basic (2, bool, proto3) ^:: nil)
    in
    let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
    fun writer -> deserialize writer |> Runtime'.Result.open_error
end

and TaskReplyToOverwriteResponse : sig
  val name' : unit -> string

  type t = unit [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Runtime'.Writer.t
  val from_proto : Runtime'.Reader.t -> (t, [> Runtime'.Result.error ]) result
end = struct
  let name' () = "task.TaskReplyToOverwriteResponse"

  type t = unit [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f () = f [] in
    let spec = Runtime'.Serialize.C.(nil) in
    let serialize = Runtime'.Serialize.serialize [] spec in
    fun t -> apply ~f:serialize t

  let from_proto =
    let constructor _extension = () in
    let spec = Runtime'.Deserialize.C.(nil) in
    let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
    fun writer -> deserialize writer |> Runtime'.Result.open_error
end

and TaskReplyToRenameRequest : sig
  val name' : unit -> string

  type t = {
    taskId : string;
    newName : string;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Runtime'.Writer.t
  val from_proto : Runtime'.Reader.t -> (t, [> Runtime'.Result.error ]) result
end = struct
  let name' () = "task.TaskReplyToRenameRequest"

  type t = {
    taskId : string;
    newName : string;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f:f' { taskId; newName } = f' [] taskId newName in
    let spec =
      Runtime'.Serialize.C.(basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil)
    in
    let serialize = Runtime'.Serialize.serialize [] spec in
    fun t -> apply ~f:serialize t

  let from_proto =
    let constructor _extensions taskId newName = { taskId; newName } in
    let spec =
      Runtime'.Deserialize.C.(basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil)
    in
    let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
    fun writer -> deserialize writer |> Runtime'.Result.open_error
end

and TaskReplyToRenameResponse : sig
  val name' : unit -> string

  type t = unit [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Runtime'.Writer.t
  val from_proto : Runtime'.Reader.t -> (t, [> Runtime'.Result.error ]) result
end = struct
  let name' () = "task.TaskReplyToRenameResponse"

  type t = unit [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f () = f [] in
    let spec = Runtime'.Serialize.C.(nil) in
    let serialize = Runtime'.Serialize.serialize [] spec in
    fun t -> apply ~f:serialize t

  let from_proto =
    let constructor _extension = () in
    let spec = Runtime'.Deserialize.C.(nil) in
    let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
    fun writer -> deserialize writer |> Runtime'.Result.open_error
end

and TaskCancelRequest : sig
  val name' : unit -> string

  type t = { taskId : string }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Runtime'.Writer.t
  val from_proto : Runtime'.Reader.t -> (t, [> Runtime'.Result.error ]) result
end = struct
  let name' () = "task.TaskCancelRequest"

  type t = { taskId : string }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f:f' { taskId } = f' [] taskId in
    let spec = Runtime'.Serialize.C.(basic (1, string, proto3) ^:: nil) in
    let serialize = Runtime'.Serialize.serialize [] spec in
    fun t -> apply ~f:serialize t

  let from_proto =
    let constructor _extensions taskId = { taskId } in
    let spec = Runtime'.Deserialize.C.(basic (1, string, proto3) ^:: nil) in
    let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
    fun writer -> deserialize writer |> Runtime'.Result.open_error
end

and TaskCancelResponse : sig
  val name' : unit -> string

  type t = unit [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Runtime'.Writer.t
  val from_proto : Runtime'.Reader.t -> (t, [> Runtime'.Result.error ]) result
end = struct
  let name' () = "task.TaskCancelResponse"

  type t = unit [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f () = f [] in
    let spec = Runtime'.Serialize.C.(nil) in
    let serialize = Runtime'.Serialize.serialize [] spec in
    fun t -> apply ~f:serialize t

  let from_proto =
    let constructor _extension = () in
    let spec = Runtime'.Deserialize.C.(nil) in
    let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
    fun writer -> deserialize writer |> Runtime'.Result.open_error
end
