(************************************************)
(*       AUTOGENERATED FILE - DO NOT EDIT!      *)
(************************************************)
(* Generated by: ocaml-protoc-plugin            *)
(* https://github.com/issuu/ocaml-protoc-plugin *)
(************************************************)
(* Source: filer.proto Syntax: proto3 Parameters: annot='[@@deriving eq, show, protocol
   ~driver:(module Protocol_conv_json.Json)]' debug=false opens=[] int64_as_int=true
   int32_as_int=true fixed_as_int=false singleton_record=false *)
module rec Capability : sig
  val name' : unit -> string

  type t = {
    writable : bool;
    readable : bool;
    executable : bool;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Ocaml_protoc_plugin.Writer.t
  val from_proto : Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct
  let name' () = "Filer.Capability"

  type t = {
    writable : bool;
    readable : bool;
    executable : bool;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f:f' { writable; readable; executable } = f' writable readable executable in
    let spec =
      Ocaml_protoc_plugin.Serialize.C.(
        basic (1, bool, proto3) ^:: basic (2, bool, proto3) ^:: basic (3, bool, proto3) ^:: nil)
    in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize spec in
    fun t -> apply ~f:(serialize ()) t

  let from_proto =
    let constructor writable readable executable = { writable; readable; executable } in
    let spec =
      Ocaml_protoc_plugin.Deserialize.C.(
        basic (1, bool, proto3) ^:: basic (2, bool, proto3) ^:: basic (3, bool, proto3) ^:: nil)
    in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize spec constructor in
    fun writer -> deserialize writer
end

and Mode : sig
  val name' : unit -> string

  type t = {
    owner : Capability.t option;
    group : Capability.t option;
    others : Capability.t option;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Ocaml_protoc_plugin.Writer.t
  val from_proto : Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct
  let name' () = "Filer.Mode"

  type t = {
    owner : Capability.t option;
    group : Capability.t option;
    others : Capability.t option;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f:f' { owner; group; others } = f' owner group others in
    let spec =
      Ocaml_protoc_plugin.Serialize.C.(
        basic_opt (1, message Capability.to_proto)
        ^:: basic_opt (2, message Capability.to_proto)
        ^:: basic_opt (3, message Capability.to_proto)
        ^:: nil)
    in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize spec in
    fun t -> apply ~f:(serialize ()) t

  let from_proto =
    let constructor owner group others = { owner; group; others } in
    let spec =
      Ocaml_protoc_plugin.Deserialize.C.(
        basic_opt (1, message Capability.from_proto)
        ^:: basic_opt (2, message Capability.from_proto)
        ^:: basic_opt (3, message Capability.from_proto)
        ^:: nil)
    in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize spec constructor in
    fun writer -> deserialize writer
end

and FileStat : sig
  val name' : unit -> string

  type t = {
    mode : Mode.t option;
    uid : int;
    gid : int;
    atime : string;
    ctime : string;
    mtime : string;
    size : string;
    isDirectory : bool;
    isFile : bool;
    isSymlink : bool;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Ocaml_protoc_plugin.Writer.t
  val from_proto : Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct
  let name' () = "Filer.FileStat"

  type t = {
    mode : Mode.t option;
    uid : int;
    gid : int;
    atime : string;
    ctime : string;
    mtime : string;
    size : string;
    isDirectory : bool;
    isFile : bool;
    isSymlink : bool;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f:f' { mode; uid; gid; atime; ctime; mtime; size; isDirectory; isFile; isSymlink } =
      f' mode uid gid atime ctime mtime size isDirectory isFile isSymlink
    in
    let spec =
      Ocaml_protoc_plugin.Serialize.C.(
        basic_opt (1, message Mode.to_proto)
        ^:: basic (2, int32_int, proto3)
        ^:: basic (3, int32_int, proto3)
        ^:: basic (4, string, proto3)
        ^:: basic (5, string, proto3)
        ^:: basic (6, string, proto3)
        ^:: basic (7, string, proto3)
        ^:: basic (8, bool, proto3)
        ^:: basic (9, bool, proto3)
        ^:: basic (10, bool, proto3)
        ^:: nil)
    in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize spec in
    fun t -> apply ~f:(serialize ()) t

  let from_proto =
    let constructor mode uid gid atime ctime mtime size isDirectory isFile isSymlink =
      { mode; uid; gid; atime; ctime; mtime; size; isDirectory; isFile; isSymlink }
    in
    let spec =
      Ocaml_protoc_plugin.Deserialize.C.(
        basic_opt (1, message Mode.from_proto)
        ^:: basic (2, int32_int, proto3)
        ^:: basic (3, int32_int, proto3)
        ^:: basic (4, string, proto3)
        ^:: basic (5, string, proto3)
        ^:: basic (6, string, proto3)
        ^:: basic (7, string, proto3)
        ^:: basic (8, bool, proto3)
        ^:: basic (9, bool, proto3)
        ^:: basic (10, bool, proto3)
        ^:: nil)
    in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize spec constructor in
    fun writer -> deserialize writer
end

and FileItem : sig
  val name' : unit -> string

  type t = {
    id : string;
    parent : string;
    name : string;
    fullPath : string;
    stat : FileStat.t option;
    hasLinkPath : bool;
    linkPath : string;
    marked : bool;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Ocaml_protoc_plugin.Writer.t
  val from_proto : Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct
  let name' () = "Filer.FileItem"

  type t = {
    id : string;
    parent : string;
    name : string;
    fullPath : string;
    stat : FileStat.t option;
    hasLinkPath : bool;
    linkPath : string;
    marked : bool;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f:f' { id; parent; name; fullPath; stat; hasLinkPath; linkPath; marked } =
      f' id parent name fullPath stat hasLinkPath linkPath marked
    in
    let spec =
      Ocaml_protoc_plugin.Serialize.C.(
        basic (1, string, proto3)
        ^:: basic (2, string, proto3)
        ^:: basic (3, string, proto3)
        ^:: basic (4, string, proto3)
        ^:: basic_opt (5, message FileStat.to_proto)
        ^:: basic (6, bool, proto3)
        ^:: basic (7, string, proto3)
        ^:: basic (8, bool, proto3)
        ^:: nil)
    in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize spec in
    fun t -> apply ~f:(serialize ()) t

  let from_proto =
    let constructor id parent name fullPath stat hasLinkPath linkPath marked =
      { id; parent; name; fullPath; stat; hasLinkPath; linkPath; marked }
    in
    let spec =
      Ocaml_protoc_plugin.Deserialize.C.(
        basic (1, string, proto3)
        ^:: basic (2, string, proto3)
        ^:: basic (3, string, proto3)
        ^:: basic (4, string, proto3)
        ^:: basic_opt (5, message FileStat.from_proto)
        ^:: basic (6, bool, proto3)
        ^:: basic (7, string, proto3)
        ^:: basic (8, bool, proto3)
        ^:: nil)
    in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize spec constructor in
    fun writer -> deserialize writer
end

and FileList : sig
  val name' : unit -> string

  type t = {
    location : string;
    items : FileItem.t list;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Ocaml_protoc_plugin.Writer.t
  val from_proto : Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct
  let name' () = "Filer.FileList"

  type t = {
    location : string;
    items : FileItem.t list;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f:f' { location; items } = f' location items in
    let spec =
      Ocaml_protoc_plugin.Serialize.C.(
        basic (1, string, proto3) ^:: repeated (2, message FileItem.to_proto, not_packed) ^:: nil)
    in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize spec in
    fun t -> apply ~f:(serialize ()) t

  let from_proto =
    let constructor location items = { location; items } in
    let spec =
      Ocaml_protoc_plugin.Deserialize.C.(
        basic (1, string, proto3) ^:: repeated (2, message FileItem.from_proto, not_packed) ^:: nil)
    in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize spec constructor in
    fun writer -> deserialize writer
end

and LocationHistory : sig
  val name' : unit -> string

  type t = {
    records : LocationRecord.t list;
    maxRecordNumber : int;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Ocaml_protoc_plugin.Writer.t
  val from_proto : Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct
  let name' () = "Filer.LocationHistory"

  type t = {
    records : LocationRecord.t list;
    maxRecordNumber : int;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f:f' { records; maxRecordNumber } = f' records maxRecordNumber in
    let spec =
      Ocaml_protoc_plugin.Serialize.C.(
        repeated (1, message LocationRecord.to_proto, not_packed)
        ^:: basic (2, int32_int, proto3)
        ^:: nil)
    in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize spec in
    fun t -> apply ~f:(serialize ()) t

  let from_proto =
    let constructor records maxRecordNumber = { records; maxRecordNumber } in
    let spec =
      Ocaml_protoc_plugin.Deserialize.C.(
        repeated (1, message LocationRecord.from_proto, not_packed)
        ^:: basic (2, int32_int, proto3)
        ^:: nil)
    in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize spec constructor in
    fun writer -> deserialize writer
end

and LocationRecord : sig
  val name' : unit -> string

  type t = {
    location : string;
    timestamp : string;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Ocaml_protoc_plugin.Writer.t
  val from_proto : Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct
  let name' () = "Filer.LocationRecord"

  type t = {
    location : string;
    timestamp : string;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f:f' { location; timestamp } = f' location timestamp in
    let spec =
      Ocaml_protoc_plugin.Serialize.C.(
        basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil)
    in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize spec in
    fun t -> apply ~f:(serialize ()) t

  let from_proto =
    let constructor location timestamp = { location; timestamp } in
    let spec =
      Ocaml_protoc_plugin.Deserialize.C.(
        basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil)
    in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize spec constructor in
    fun writer -> deserialize writer
end

and Filer : sig
  val name' : unit -> string

  type t = {
    id : string;
    name : string;
    fileList : FileList.t option;
    history : LocationHistory.t option;
    markedItems : string list;
    sortOrder : Types.SortType.t;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Ocaml_protoc_plugin.Writer.t
  val from_proto : Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct
  let name' () = "Filer.Filer"

  type t = {
    id : string;
    name : string;
    fileList : FileList.t option;
    history : LocationHistory.t option;
    markedItems : string list;
    sortOrder : Types.SortType.t;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f:f' { id; name; fileList; history; markedItems; sortOrder } =
      f' id name fileList history markedItems sortOrder
    in
    let spec =
      Ocaml_protoc_plugin.Serialize.C.(
        basic (1, string, proto3)
        ^:: basic (2, string, proto3)
        ^:: basic_opt (3, message FileList.to_proto)
        ^:: basic_opt (4, message LocationHistory.to_proto)
        ^:: repeated (5, string, packed)
        ^:: basic (6, enum Types.SortType.to_int, proto3)
        ^:: nil)
    in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize spec in
    fun t -> apply ~f:(serialize ()) t

  let from_proto =
    let constructor id name fileList history markedItems sortOrder =
      { id; name; fileList; history; markedItems; sortOrder }
    in
    let spec =
      Ocaml_protoc_plugin.Deserialize.C.(
        basic (1, string, proto3)
        ^:: basic (2, string, proto3)
        ^:: basic_opt (3, message FileList.from_proto)
        ^:: basic_opt (4, message LocationHistory.from_proto)
        ^:: repeated (5, string, packed)
        ^:: basic (6, enum Types.SortType.from_int, proto3)
        ^:: nil)
    in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize spec constructor in
    fun writer -> deserialize writer
end

and FilerMakeRequest : sig
  val name' : unit -> string

  type t = {
    initialLocation : string;
    name : string;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Ocaml_protoc_plugin.Writer.t
  val from_proto : Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct
  let name' () = "Filer.FilerMakeRequest"

  type t = {
    initialLocation : string;
    name : string;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f:f' { initialLocation; name } = f' initialLocation name in
    let spec =
      Ocaml_protoc_plugin.Serialize.C.(
        basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil)
    in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize spec in
    fun t -> apply ~f:(serialize ()) t

  let from_proto =
    let constructor initialLocation name = { initialLocation; name } in
    let spec =
      Ocaml_protoc_plugin.Deserialize.C.(
        basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil)
    in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize spec constructor in
    fun writer -> deserialize writer
end

and FilerMakeResponse : sig
  val name' : unit -> string

  type t = Filer.t option [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Ocaml_protoc_plugin.Writer.t
  val from_proto : Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct
  let name' () = "Filer.FilerMakeResponse"

  type t = Filer.t option [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f a = f a in
    let spec = Ocaml_protoc_plugin.Serialize.C.(basic_opt (1, message Filer.to_proto) ^:: nil) in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize spec in
    fun t -> apply ~f:(serialize ()) t

  let from_proto =
    let constructor a = a in
    let spec =
      Ocaml_protoc_plugin.Deserialize.C.(basic_opt (1, message Filer.from_proto) ^:: nil)
    in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize spec constructor in
    fun writer -> deserialize writer
end

and FilerGetRequest : sig
  val name' : unit -> string

  type t = string [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Ocaml_protoc_plugin.Writer.t
  val from_proto : Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct
  let name' () = "Filer.FilerGetRequest"

  type t = string [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f a = f a in
    let spec = Ocaml_protoc_plugin.Serialize.C.(basic (1, string, proto3) ^:: nil) in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize spec in
    fun t -> apply ~f:(serialize ()) t

  let from_proto =
    let constructor a = a in
    let spec = Ocaml_protoc_plugin.Deserialize.C.(basic (1, string, proto3) ^:: nil) in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize spec constructor in
    fun writer -> deserialize writer
end

and FilerGetResponse : sig
  val name' : unit -> string

  type t = Filer.t option [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Ocaml_protoc_plugin.Writer.t
  val from_proto : Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct
  let name' () = "Filer.FilerGetResponse"

  type t = Filer.t option [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f a = f a in
    let spec = Ocaml_protoc_plugin.Serialize.C.(basic_opt (1, message Filer.to_proto) ^:: nil) in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize spec in
    fun t -> apply ~f:(serialize ()) t

  let from_proto =
    let constructor a = a in
    let spec =
      Ocaml_protoc_plugin.Deserialize.C.(basic_opt (1, message Filer.from_proto) ^:: nil)
    in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize spec constructor in
    fun writer -> deserialize writer
end

and FilerMoveParentRequest : sig
  val name' : unit -> string

  type t = string [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Ocaml_protoc_plugin.Writer.t
  val from_proto : Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct
  let name' () = "Filer.FilerMoveParentRequest"

  type t = string [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f a = f a in
    let spec = Ocaml_protoc_plugin.Serialize.C.(basic (1, string, proto3) ^:: nil) in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize spec in
    fun t -> apply ~f:(serialize ()) t

  let from_proto =
    let constructor a = a in
    let spec = Ocaml_protoc_plugin.Deserialize.C.(basic (1, string, proto3) ^:: nil) in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize spec constructor in
    fun writer -> deserialize writer
end

and FilerMoveParentResponse : sig
  val name' : unit -> string

  type t = Filer.t option [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Ocaml_protoc_plugin.Writer.t
  val from_proto : Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct
  let name' () = "Filer.FilerMoveParentResponse"

  type t = Filer.t option [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f a = f a in
    let spec = Ocaml_protoc_plugin.Serialize.C.(basic_opt (1, message Filer.to_proto) ^:: nil) in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize spec in
    fun t -> apply ~f:(serialize ()) t

  let from_proto =
    let constructor a = a in
    let spec =
      Ocaml_protoc_plugin.Deserialize.C.(basic_opt (1, message Filer.from_proto) ^:: nil)
    in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize spec constructor in
    fun writer -> deserialize writer
end

and FilerEnterDirectoryRequest : sig
  val name' : unit -> string

  type t = {
    name : string;
    itemId : string;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Ocaml_protoc_plugin.Writer.t
  val from_proto : Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct
  let name' () = "Filer.FilerEnterDirectoryRequest"

  type t = {
    name : string;
    itemId : string;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f:f' { name; itemId } = f' name itemId in
    let spec =
      Ocaml_protoc_plugin.Serialize.C.(
        basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil)
    in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize spec in
    fun t -> apply ~f:(serialize ()) t

  let from_proto =
    let constructor name itemId = { name; itemId } in
    let spec =
      Ocaml_protoc_plugin.Deserialize.C.(
        basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil)
    in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize spec constructor in
    fun writer -> deserialize writer
end

and FilerEnterDirectoryResponse : sig
  val name' : unit -> string

  type t = Filer.t option [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Ocaml_protoc_plugin.Writer.t
  val from_proto : Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct
  let name' () = "Filer.FilerEnterDirectoryResponse"

  type t = Filer.t option [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f a = f a in
    let spec = Ocaml_protoc_plugin.Serialize.C.(basic_opt (1, message Filer.to_proto) ^:: nil) in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize spec in
    fun t -> apply ~f:(serialize ()) t

  let from_proto =
    let constructor a = a in
    let spec =
      Ocaml_protoc_plugin.Deserialize.C.(basic_opt (1, message Filer.from_proto) ^:: nil)
    in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize spec constructor in
    fun writer -> deserialize writer
end

and FilerToggleMarkRequest : sig
  val name' : unit -> string

  type t = {
    name : string;
    itemIds : string list;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Ocaml_protoc_plugin.Writer.t
  val from_proto : Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct
  let name' () = "Filer.FilerToggleMarkRequest"

  type t = {
    name : string;
    itemIds : string list;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f:f' { name; itemIds } = f' name itemIds in
    let spec =
      Ocaml_protoc_plugin.Serialize.C.(
        basic (1, string, proto3) ^:: repeated (2, string, packed) ^:: nil)
    in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize spec in
    fun t -> apply ~f:(serialize ()) t

  let from_proto =
    let constructor name itemIds = { name; itemIds } in
    let spec =
      Ocaml_protoc_plugin.Deserialize.C.(
        basic (1, string, proto3) ^:: repeated (2, string, packed) ^:: nil)
    in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize spec constructor in
    fun writer -> deserialize writer
end

and FilerToggleMarkResponse : sig
  val name' : unit -> string

  type t = Filer.t option [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Ocaml_protoc_plugin.Writer.t
  val from_proto : Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct
  let name' () = "Filer.FilerToggleMarkResponse"

  type t = Filer.t option [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f a = f a in
    let spec = Ocaml_protoc_plugin.Serialize.C.(basic_opt (1, message Filer.to_proto) ^:: nil) in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize spec in
    fun t -> apply ~f:(serialize ()) t

  let from_proto =
    let constructor a = a in
    let spec =
      Ocaml_protoc_plugin.Deserialize.C.(basic_opt (1, message Filer.from_proto) ^:: nil)
    in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize spec constructor in
    fun writer -> deserialize writer
end

and FilerMoveRequest : sig
  val name' : unit -> string

  type t = {
    source : string;
    dest : string;
    itemIds : string list;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Ocaml_protoc_plugin.Writer.t
  val from_proto : Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct
  let name' () = "Filer.FilerMoveRequest"

  type t = {
    source : string;
    dest : string;
    itemIds : string list;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f:f' { source; dest; itemIds } = f' source dest itemIds in
    let spec =
      Ocaml_protoc_plugin.Serialize.C.(
        basic (1, string, proto3)
        ^:: basic (2, string, proto3)
        ^:: repeated (3, string, packed)
        ^:: nil)
    in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize spec in
    fun t -> apply ~f:(serialize ()) t

  let from_proto =
    let constructor source dest itemIds = { source; dest; itemIds } in
    let spec =
      Ocaml_protoc_plugin.Deserialize.C.(
        basic (1, string, proto3)
        ^:: basic (2, string, proto3)
        ^:: repeated (3, string, packed)
        ^:: nil)
    in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize spec constructor in
    fun writer -> deserialize writer
end

and FilerMoveResponse : sig
  val name' : unit -> string

  type t = {
    taskId : string;
    taskName : string;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Ocaml_protoc_plugin.Writer.t
  val from_proto : Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct
  let name' () = "Filer.FilerMoveResponse"

  type t = {
    taskId : string;
    taskName : string;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f:f' { taskId; taskName } = f' taskId taskName in
    let spec =
      Ocaml_protoc_plugin.Serialize.C.(
        basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil)
    in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize spec in
    fun t -> apply ~f:(serialize ()) t

  let from_proto =
    let constructor taskId taskName = { taskId; taskName } in
    let spec =
      Ocaml_protoc_plugin.Deserialize.C.(
        basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil)
    in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize spec constructor in
    fun writer -> deserialize writer
end

and FilerDeleteRequest : sig
  val name' : unit -> string

  type t = {
    source : string;
    itemIds : string list;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Ocaml_protoc_plugin.Writer.t
  val from_proto : Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct
  let name' () = "Filer.FilerDeleteRequest"

  type t = {
    source : string;
    itemIds : string list;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f:f' { source; itemIds } = f' source itemIds in
    let spec =
      Ocaml_protoc_plugin.Serialize.C.(
        basic (1, string, proto3) ^:: repeated (2, string, packed) ^:: nil)
    in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize spec in
    fun t -> apply ~f:(serialize ()) t

  let from_proto =
    let constructor source itemIds = { source; itemIds } in
    let spec =
      Ocaml_protoc_plugin.Deserialize.C.(
        basic (1, string, proto3) ^:: repeated (2, string, packed) ^:: nil)
    in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize spec constructor in
    fun writer -> deserialize writer
end

and FilerDeleteResponse : sig
  val name' : unit -> string

  type t = {
    taskId : string;
    taskName : string;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Ocaml_protoc_plugin.Writer.t
  val from_proto : Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct
  let name' () = "Filer.FilerDeleteResponse"

  type t = {
    taskId : string;
    taskName : string;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f:f' { taskId; taskName } = f' taskId taskName in
    let spec =
      Ocaml_protoc_plugin.Serialize.C.(
        basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil)
    in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize spec in
    fun t -> apply ~f:(serialize ()) t

  let from_proto =
    let constructor taskId taskName = { taskId; taskName } in
    let spec =
      Ocaml_protoc_plugin.Deserialize.C.(
        basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil)
    in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize spec constructor in
    fun writer -> deserialize writer
end

and FilerCopyRequest : sig
  val name' : unit -> string

  type t = {
    source : string;
    dest : string;
    itemIds : string list;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Ocaml_protoc_plugin.Writer.t
  val from_proto : Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct
  let name' () = "Filer.FilerCopyRequest"

  type t = {
    source : string;
    dest : string;
    itemIds : string list;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f:f' { source; dest; itemIds } = f' source dest itemIds in
    let spec =
      Ocaml_protoc_plugin.Serialize.C.(
        basic (1, string, proto3)
        ^:: basic (2, string, proto3)
        ^:: repeated (3, string, packed)
        ^:: nil)
    in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize spec in
    fun t -> apply ~f:(serialize ()) t

  let from_proto =
    let constructor source dest itemIds = { source; dest; itemIds } in
    let spec =
      Ocaml_protoc_plugin.Deserialize.C.(
        basic (1, string, proto3)
        ^:: basic (2, string, proto3)
        ^:: repeated (3, string, packed)
        ^:: nil)
    in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize spec constructor in
    fun writer -> deserialize writer
end

and FilerCopyResponse : sig
  val name' : unit -> string

  type t = {
    taskId : string;
    taskName : string;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Ocaml_protoc_plugin.Writer.t
  val from_proto : Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct
  let name' () = "Filer.FilerCopyResponse"

  type t = {
    taskId : string;
    taskName : string;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f:f' { taskId; taskName } = f' taskId taskName in
    let spec =
      Ocaml_protoc_plugin.Serialize.C.(
        basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil)
    in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize spec in
    fun t -> apply ~f:(serialize ()) t

  let from_proto =
    let constructor taskId taskName = { taskId; taskName } in
    let spec =
      Ocaml_protoc_plugin.Deserialize.C.(
        basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil)
    in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize spec constructor in
    fun writer -> deserialize writer
end

and FilerJumpLocationRequest : sig
  val name' : unit -> string

  type t = {
    location : string;
    name : string;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Ocaml_protoc_plugin.Writer.t
  val from_proto : Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct
  let name' () = "Filer.FilerJumpLocationRequest"

  type t = {
    location : string;
    name : string;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f:f' { location; name } = f' location name in
    let spec =
      Ocaml_protoc_plugin.Serialize.C.(
        basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil)
    in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize spec in
    fun t -> apply ~f:(serialize ()) t

  let from_proto =
    let constructor location name = { location; name } in
    let spec =
      Ocaml_protoc_plugin.Deserialize.C.(
        basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil)
    in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize spec constructor in
    fun writer -> deserialize writer
end

and FilerJumpLocationResponse : sig
  val name' : unit -> string

  type t = Filer.t option [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Ocaml_protoc_plugin.Writer.t
  val from_proto : Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct
  let name' () = "Filer.FilerJumpLocationResponse"

  type t = Filer.t option [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f a = f a in
    let spec = Ocaml_protoc_plugin.Serialize.C.(basic_opt (1, message Filer.to_proto) ^:: nil) in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize spec in
    fun t -> apply ~f:(serialize ()) t

  let from_proto =
    let constructor a = a in
    let spec =
      Ocaml_protoc_plugin.Deserialize.C.(basic_opt (1, message Filer.from_proto) ^:: nil)
    in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize spec constructor in
    fun writer -> deserialize writer
end
