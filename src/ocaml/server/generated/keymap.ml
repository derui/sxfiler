(************************************************)
(*       AUTOGENERATED FILE - DO NOT EDIT!      *)
(************************************************)
(* Generated by: ocaml-protoc-plugin            *)
(* https://github.com/issuu/ocaml-protoc-plugin *)
(************************************************)
(* Source: keymap.proto Syntax: proto3 Parameters: annot='[@@deriving eq, show, protocol
   ~driver:(module Protocol_conv_json.Json)]' debug=false opens=[] int64_as_int=true
   int32_as_int=true fixed_as_int=false singleton_record=false *)
module rec Keymap : sig
  val name' : unit -> string

  type t = Binding.t list [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Ocaml_protoc_plugin.Writer.t
  val from_proto : Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct
  let name' () = "Keymap.Keymap"

  type t = Binding.t list [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f a = f a in
    let spec =
      Ocaml_protoc_plugin.Serialize.C.(repeated (1, message Binding.to_proto, not_packed) ^:: nil)
    in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize spec in
    fun t -> apply ~f:(serialize ()) t

  let from_proto =
    let constructor a = a in
    let spec =
      Ocaml_protoc_plugin.Deserialize.C.(
        repeated (1, message Binding.from_proto, not_packed) ^:: nil)
    in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize spec constructor in
    fun writer -> deserialize writer
end

and Binding : sig
  val name' : unit -> string

  type t = {
    key : string;
    action : string;
    when' : When.t option;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Ocaml_protoc_plugin.Writer.t
  val from_proto : Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct
  let name' () = "Keymap.Binding"

  type t = {
    key : string;
    action : string;
    when' : When.t option;
  }
  [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f:f' { key; action; when' } = f' key action when' in
    let spec =
      Ocaml_protoc_plugin.Serialize.C.(
        basic (1, string, proto3)
        ^:: basic (2, string, proto3)
        ^:: basic_opt (3, message When.to_proto)
        ^:: nil)
    in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize spec in
    fun t -> apply ~f:(serialize ()) t

  let from_proto =
    let constructor key action when' = { key; action; when' } in
    let spec =
      Ocaml_protoc_plugin.Deserialize.C.(
        basic (1, string, proto3)
        ^:: basic (2, string, proto3)
        ^:: basic_opt (3, message When.from_proto)
        ^:: nil)
    in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize spec constructor in
    fun writer -> deserialize writer
end

and When : sig
  val name' : unit -> string

  type t = string list [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Ocaml_protoc_plugin.Writer.t
  val from_proto : Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct
  let name' () = "Keymap.When"

  type t = string list [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f a = f a in
    let spec = Ocaml_protoc_plugin.Serialize.C.(repeated (1, string, packed) ^:: nil) in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize spec in
    fun t -> apply ~f:(serialize ()) t

  let from_proto =
    let constructor a = a in
    let spec = Ocaml_protoc_plugin.Deserialize.C.(repeated (1, string, packed) ^:: nil) in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize spec constructor in
    fun writer -> deserialize writer
end

and KeymapGetRequest : sig
  val name' : unit -> string

  type t = unit [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Ocaml_protoc_plugin.Writer.t
  val from_proto : Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct
  let name' () = "Keymap.KeymapGetRequest"

  type t = unit [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f () = f in
    let spec = Ocaml_protoc_plugin.Serialize.C.(nil) in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize spec in
    fun t -> apply ~f:(serialize ()) t

  let from_proto =
    let constructor = () in
    let spec = Ocaml_protoc_plugin.Deserialize.C.(nil) in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize spec constructor in
    fun writer -> deserialize writer
end

and KeymapGetResponse : sig
  val name' : unit -> string

  type t = Keymap.t option [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Ocaml_protoc_plugin.Writer.t
  val from_proto : Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct
  let name' () = "Keymap.KeymapGetResponse"

  type t = Keymap.t option [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f a = f a in
    let spec = Ocaml_protoc_plugin.Serialize.C.(basic_opt (1, message Keymap.to_proto) ^:: nil) in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize spec in
    fun t -> apply ~f:(serialize ()) t

  let from_proto =
    let constructor a = a in
    let spec =
      Ocaml_protoc_plugin.Deserialize.C.(basic_opt (1, message Keymap.from_proto) ^:: nil)
    in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize spec constructor in
    fun writer -> deserialize writer
end

and KeymapReloadRequest : sig
  val name' : unit -> string

  type t = unit [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Ocaml_protoc_plugin.Writer.t
  val from_proto : Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct
  let name' () = "Keymap.KeymapReloadRequest"

  type t = unit [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f () = f in
    let spec = Ocaml_protoc_plugin.Serialize.C.(nil) in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize spec in
    fun t -> apply ~f:(serialize ()) t

  let from_proto =
    let constructor = () in
    let spec = Ocaml_protoc_plugin.Deserialize.C.(nil) in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize spec constructor in
    fun writer -> deserialize writer
end

and KeymapReloadResponse : sig
  val name' : unit -> string

  type t = Keymap.t option [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Ocaml_protoc_plugin.Writer.t
  val from_proto : Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct
  let name' () = "Keymap.KeymapReloadResponse"

  type t = Keymap.t option [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f a = f a in
    let spec = Ocaml_protoc_plugin.Serialize.C.(basic_opt (1, message Keymap.to_proto) ^:: nil) in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize spec in
    fun t -> apply ~f:(serialize ()) t

  let from_proto =
    let constructor a = a in
    let spec =
      Ocaml_protoc_plugin.Deserialize.C.(basic_opt (1, message Keymap.from_proto) ^:: nil)
    in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize spec constructor in
    fun writer -> deserialize writer
end

and KeymapStoreRequest : sig
  val name' : unit -> string

  type t = Keymap.t option [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Ocaml_protoc_plugin.Writer.t
  val from_proto : Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct
  let name' () = "Keymap.KeymapStoreRequest"

  type t = Keymap.t option [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f a = f a in
    let spec = Ocaml_protoc_plugin.Serialize.C.(basic_opt (1, message Keymap.to_proto) ^:: nil) in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize spec in
    fun t -> apply ~f:(serialize ()) t

  let from_proto =
    let constructor a = a in
    let spec =
      Ocaml_protoc_plugin.Deserialize.C.(basic_opt (1, message Keymap.from_proto) ^:: nil)
    in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize spec constructor in
    fun writer -> deserialize writer
end

and KeymapStoreResponse : sig
  val name' : unit -> string

  type t = unit [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  val to_proto : t -> Ocaml_protoc_plugin.Writer.t
  val from_proto : Ocaml_protoc_plugin.Reader.t -> t Ocaml_protoc_plugin.Result.t
end = struct
  let name' () = "Keymap.KeymapStoreResponse"

  type t = unit [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

  let to_proto =
    let apply ~f () = f in
    let spec = Ocaml_protoc_plugin.Serialize.C.(nil) in
    let serialize = Ocaml_protoc_plugin.Serialize.serialize spec in
    fun t -> apply ~f:(serialize ()) t

  let from_proto =
    let constructor = () in
    let spec = Ocaml_protoc_plugin.Deserialize.C.(nil) in
    let deserialize = Ocaml_protoc_plugin.Deserialize.deserialize spec constructor in
    fun writer -> deserialize writer
end
