(************************************************)
(*       AUTOGENERATED FILE - DO NOT EDIT!      *)
(************************************************)
(* Generated by: ocaml-protoc-plugin            *)
(* https://github.com/issuu/ocaml-protoc-plugin *)
(************************************************)
(*
   Source: completer.proto
   Syntax: proto3 
   Parameters:
     debug=false
     annot='[@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]'
     opens=[]
     int64_as_int=true
     int32_as_int=true
     fixed_as_int=false
     singleton_record=true
*)

open Ocaml_protoc_plugin.Runtime [@@warning "-33"]
module Completer = struct
  module rec Item : sig
    val name': unit -> string
    type t = { id: string; value: string } [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "completer.completer.Item"
    type t = { id: string; value: string }[@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]
    let to_proto =
      let apply = fun ~f:f' { id; value } -> f' [] id value in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions id value -> { id; value } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and Candidate : sig
    val name': unit -> string
    type t = { start: int; length: int; value: Item.t option } [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "completer.completer.Candidate"
    type t = { start: int; length: int; value: Item.t option }[@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]
    let to_proto =
      let apply = fun ~f:f' { start; length; value } -> f' [] start length value in
      let spec = Runtime'.Serialize.C.( basic (1, int32_int, proto3) ^:: basic (2, int32_int, proto3) ^:: basic_opt (3, (message (fun t -> Item.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions start length value -> { start; length; value } in
      let spec = Runtime'.Deserialize.C.( basic (1, int32_int, proto3) ^:: basic (2, int32_int, proto3) ^:: basic_opt (3, (message (fun t -> Item.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and InitializeRequest : sig
    val name': unit -> string
    type t = { source: Item.t list } [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "completer.completer.InitializeRequest"
    type t = { source: Item.t list }[@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]
    let to_proto =
      let apply = fun ~f:f' { source } -> f' [] source in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Item.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions source -> { source } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Item.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and InitializeResponse : sig
    val name': unit -> string
    type t = unit [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "completer.completer.InitializeResponse"
    type t = unit[@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]
    let to_proto =
      let apply = fun ~f () -> f [] in
      let spec = Runtime'.Serialize.C.( nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extension -> () in
      let spec = Runtime'.Deserialize.C.( nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CompleteRequest : sig
    val name': unit -> string
    type t = { input: string } [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "completer.completer.CompleteRequest"
    type t = { input: string }[@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]
    let to_proto =
      let apply = fun ~f:f' { input } -> f' [] input in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions input -> { input } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CompleteResponse : sig
    val name': unit -> string
    type t = unit [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "completer.completer.CompleteResponse"
    type t = unit[@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]
    let to_proto =
      let apply = fun ~f () -> f [] in
      let spec = Runtime'.Serialize.C.( nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extension -> () in
      let spec = Runtime'.Deserialize.C.( nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CompletionResultNotificationRequest : sig
    val name': unit -> string
    type t = { candidates: Candidate.t list } [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "completer.completer.CompletionResultNotificationRequest"
    type t = { candidates: Candidate.t list }[@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]
    let to_proto =
      let apply = fun ~f:f' { candidates } -> f' [] candidates in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Candidate.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions candidates -> { candidates } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Candidate.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CompletionResultNotificationResponse : sig
    val name': unit -> string
    type t = unit [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "completer.completer.CompletionResultNotificationResponse"
    type t = unit[@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]
    let to_proto =
      let apply = fun ~f () -> f [] in
      let spec = Runtime'.Serialize.C.( nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extension -> () in
      let spec = Runtime'.Deserialize.C.( nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
end