(************************************************)
(*       AUTOGENERATED FILE - DO NOT EDIT!      *)
(************************************************)
(* Generated by: ocaml-protoc-plugin            *)
(* https://github.com/issuu/ocaml-protoc-plugin *)
(************************************************)
(* Source: theme.proto Syntax: proto3 Parameters: debug=false annot='[@@deriving eq, show, protocol ~driver:(module
   Protocol_conv_json.Json)]' opens=[] int64_as_int=true int32_as_int=true fixed_as_int=false singleton_record=true *)

open Ocaml_protoc_plugin.Runtime [@@warning "-33"]

module Theme = struct
  module rec ColorCode : sig
    val name' : unit -> string

    type t = {
      name : string;
      hex_color : string;
    }
    [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

    val to_proto : t -> Runtime'.Writer.t

    val from_proto : Runtime'.Reader.t -> (t, [> Runtime'.Result.error ]) result
  end = struct
    let name' () = "theme.theme.ColorCode"

    type t = {
      name : string;
      hex_color : string;
    }
    [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

    let to_proto =
      let apply ~f:f' { name; hex_color } = f' [] name hex_color in
      let spec = Runtime'.Serialize.C.(basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil) in
      let serialize = Runtime'.Serialize.serialize [] spec in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor _extensions name hex_color = { name; hex_color } in
      let spec = Runtime'.Deserialize.C.(basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
  end

  and Theme : sig
    val name' : unit -> string

    type t = {
      name : string;
      description : string;
      color_codes : ColorCode.t list;
    }
    [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

    val to_proto : t -> Runtime'.Writer.t

    val from_proto : Runtime'.Reader.t -> (t, [> Runtime'.Result.error ]) result
  end = struct
    let name' () = "theme.theme.Theme"

    type t = {
      name : string;
      description : string;
      color_codes : ColorCode.t list;
    }
    [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

    let to_proto =
      let apply ~f:f' { name; description; color_codes } = f' [] name description color_codes in
      let spec =
        Runtime'.Serialize.C.(
          basic (1, string, proto3)
          ^:: basic (2, string, proto3)
          ^:: repeated (3, message (fun t -> ColorCode.to_proto t), not_packed)
          ^:: nil)
      in
      let serialize = Runtime'.Serialize.serialize [] spec in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor _extensions name description color_codes = { name; description; color_codes } in
      let spec =
        Runtime'.Deserialize.C.(
          basic (1, string, proto3)
          ^:: basic (2, string, proto3)
          ^:: repeated (3, message (fun t -> ColorCode.from_proto t), not_packed)
          ^:: nil)
      in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
  end

  and ListRequest : sig
    val name' : unit -> string

    type t = unit [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

    val to_proto : t -> Runtime'.Writer.t

    val from_proto : Runtime'.Reader.t -> (t, [> Runtime'.Result.error ]) result
  end = struct
    let name' () = "theme.theme.ListRequest"

    type t = unit [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

    let to_proto =
      let apply ~f () = f [] in
      let spec = Runtime'.Serialize.C.(nil) in
      let serialize = Runtime'.Serialize.serialize [] spec in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor _extension = () in
      let spec = Runtime'.Deserialize.C.(nil) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
  end

  and ListResponse : sig
    val name' : unit -> string

    type t = { themes : Theme.t list } [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

    val to_proto : t -> Runtime'.Writer.t

    val from_proto : Runtime'.Reader.t -> (t, [> Runtime'.Result.error ]) result
  end = struct
    let name' () = "theme.theme.ListResponse"

    type t = { themes : Theme.t list } [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

    let to_proto =
      let apply ~f:f' { themes } = f' [] themes in
      let spec = Runtime'.Serialize.C.(repeated (1, message (fun t -> Theme.to_proto t), not_packed) ^:: nil) in
      let serialize = Runtime'.Serialize.serialize [] spec in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor _extensions themes = { themes } in
      let spec = Runtime'.Deserialize.C.(repeated (1, message (fun t -> Theme.from_proto t), not_packed) ^:: nil) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
  end

  and RemoveRequest : sig
    val name' : unit -> string

    type t = { name : string } [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

    val to_proto : t -> Runtime'.Writer.t

    val from_proto : Runtime'.Reader.t -> (t, [> Runtime'.Result.error ]) result
  end = struct
    let name' () = "theme.theme.RemoveRequest"

    type t = { name : string } [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

    let to_proto =
      let apply ~f:f' { name } = f' [] name in
      let spec = Runtime'.Serialize.C.(basic (1, string, proto3) ^:: nil) in
      let serialize = Runtime'.Serialize.serialize [] spec in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor _extensions name = { name } in
      let spec = Runtime'.Deserialize.C.(basic (1, string, proto3) ^:: nil) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
  end

  and RemoveResponse : sig
    val name' : unit -> string

    type t = unit [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

    val to_proto : t -> Runtime'.Writer.t

    val from_proto : Runtime'.Reader.t -> (t, [> Runtime'.Result.error ]) result
  end = struct
    let name' () = "theme.theme.RemoveResponse"

    type t = unit [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

    let to_proto =
      let apply ~f () = f [] in
      let spec = Runtime'.Serialize.C.(nil) in
      let serialize = Runtime'.Serialize.serialize [] spec in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor _extension = () in
      let spec = Runtime'.Deserialize.C.(nil) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
  end

  and AddRequest : sig
    val name' : unit -> string

    type t = {
      name : string;
      description : string;
      color_codes : ColorCode.t list;
    }
    [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

    val to_proto : t -> Runtime'.Writer.t

    val from_proto : Runtime'.Reader.t -> (t, [> Runtime'.Result.error ]) result
  end = struct
    let name' () = "theme.theme.AddRequest"

    type t = {
      name : string;
      description : string;
      color_codes : ColorCode.t list;
    }
    [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

    let to_proto =
      let apply ~f:f' { name; description; color_codes } = f' [] name description color_codes in
      let spec =
        Runtime'.Serialize.C.(
          basic (1, string, proto3)
          ^:: basic (2, string, proto3)
          ^:: repeated (3, message (fun t -> ColorCode.to_proto t), not_packed)
          ^:: nil)
      in
      let serialize = Runtime'.Serialize.serialize [] spec in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor _extensions name description color_codes = { name; description; color_codes } in
      let spec =
        Runtime'.Deserialize.C.(
          basic (1, string, proto3)
          ^:: basic (2, string, proto3)
          ^:: repeated (3, message (fun t -> ColorCode.from_proto t), not_packed)
          ^:: nil)
      in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
  end

  and AddResponse : sig
    val name' : unit -> string

    type t = { theme : Theme.t option } [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

    val to_proto : t -> Runtime'.Writer.t

    val from_proto : Runtime'.Reader.t -> (t, [> Runtime'.Result.error ]) result
  end = struct
    let name' () = "theme.theme.AddResponse"

    type t = { theme : Theme.t option } [@@deriving eq, show, protocol ~driver:(module Protocol_conv_json.Json)]

    let to_proto =
      let apply ~f:f' { theme } = f' [] theme in
      let spec = Runtime'.Serialize.C.(basic_opt (1, message (fun t -> Theme.to_proto t)) ^:: nil) in
      let serialize = Runtime'.Serialize.serialize [] spec in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor _extensions theme = { theme } in
      let spec = Runtime'.Deserialize.C.(basic_opt (1, message (fun t -> Theme.from_proto t)) ^:: nil) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
  end
end
